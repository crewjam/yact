// Copyright (c) 2010 Ross Kinder. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#ifndef YACT_H_
#define YACT_H_

/// \mainpage YACT API Reference Guide
///
/// YACT is (yet another) C++ library to help parsing command line arguments,
/// configuration files and other mechanisms.  YACT includes utilities to
/// generate derivitives such as man pages, usage text, and so on.
///
/// YACT is designed to handle common configuration tasks, such
/// as parsing command line switchs, configuration files and switches set in the
/// environment.  The interface is in parts inspired by Python's optparse
/// (http://svn.python.org/projects/python/trunk/Lib/optparse.py), and also by
/// Google Gflags (http://code.google.com/p/google-gflags/)
///
/// Features:
///  - Flexible configuration file parsing of INI-style, JSON-style, or 
///    Apache-style configuration files.
///  - command line switch parsing with support for GNU-style long switchs and
///    POSIX-style short
///  - Global switches a la gflags
///  - Automatically generated man pages and --help output
///  - Custom switch validators
///  - Overriding switches from environment variables
///  - On Windows, reading configuration from the registry.
///  - The ability to construct configuration files and command lines, or edit
///    configuration files preserving user formatting and comments.  (Not yet 
///    implementation)
///
/// You can pick and choose among the advanced features of the library, but most
/// of the features are available in the simple usage.
/// 
/// Several examples of basic usage are provided in the examples/ directory 
/// accompanying this library.  For an even more detailed expression of the 
/// idiosynchracies of the library, examine the unittests.  For now, here is a 
/// simple example to get you started:
/// 
/// \code
///   int main(int argc, char ** argv) {
///     yact::ArgumentParser parser;
///   }
/// \endcode
///
/// Overview of major classes:
///
///  ArgumentParser        Perform parsing of command line arguments
///  [FORMAT]ConfigParser  Perform parsing of configuration files, where *Format*
///                        is one of `Apache`, `Ini`, or `Json`.
///
///  Switch                Describes the type, purpose and constrains of a switch
///  SwitchSet             Constrains the allowable switches for an
///                        ArgumentParser, ConfigParser, etc.
///  Value                 The actual value of a switch
///  ValueGroup            A named collection of values as groups by e.g. a
///                        config file section.
///
/// \section using Using the library
///
/// We have provided GNU-style autotools build environment suitable for Linux,
/// Mac, et al as well as MinGW on Windows.  If you are building with
/// VisualStudio you will find two library projects, 'yact-mt' and 'yact-md'
/// which build static library files for the static and DLL runtime library
/// respectively.  We do not currently support compiling YACT as a DLL on
/// Windows.
/// 
/// If these do not meet your needs, you can choose to copy this header file and
/// switchs-impl.cc directly into your project.  This file is automatically
/// generated by concatenating all private headers and implementation files.
///
#include <string>
#include <vector>
#include <map>

namespace yact {

// If the nobody has defined the string type, then try to guess it
// TODO(ross): I'm pretty sure this is the wrong thing to do for cases where 
//   we are installed as a system-wide library.  What if the library customer
//   wants a different string type?  How does a customer know what type of
//   string was used for the system wide library?  Maybe pkg-config?
#if !defined(YACT_STRING_CHAR) || !defined(YACT_STRING_WCHAR)
#if defined(_WIN32) && defined(_UNICODE)
#define YACT_STRING_CHAR
#else  // !_WIN32 && !_UNICODE
#define YACT_STRING_CHAR
#endif
#endif

#if defined(YACT_STRING_CHAR)
typedef char CharType;
typedef std::string StringType;
#define TT(x) x
#endif  // defined(YACT_STRING_CHAR)

#if defined(YACT_STRING_WCHAR)
typedef wchar_t CharType;
typedef std::wstring StringType;
#define TT(x) L##x
#endif  // defined(YACT_STRING_CHAR)

typedef const CharType * ConstCharArrayType;
extern const StringType kEmptyString;

class Value;
class ValueGroup;
class Switch;
class SwitchValidator;

/// Describes the value of a switch.
///
/// It is implicitly castable to the concrete types that we support, which allow
/// for convenient access, e.g.:
///
/// \code
///   ArgumentParser switch_parser;
///   switch_parser.add_switch(Switch().name("verbose").action("count"));
///   if (!switch_parser.Parse(argc, argv)) {
///     switch_parser.ComplainAndPrintUsage();
///     return 1;
///   }
///   Value verboseness = switch_parser["verbose"];
///   if (verboseness > 1) {
///     printf("welcome to my program\n");
///   }
///   // ...
/// \endcode
///
/// Some switchs, like those read from a schema-free config file, may not have an
/// explicit type and thus it may be more appopriate to do some more explicit
/// casting.  For example:
///
/// \code
///   ApacheConfigParser config_parser;
///   if (!config_parser.Parse("/etc/apache2/httpd.conf")) {
///     return false;
///   }
///   Value limit_switch = config_parser["SomeSection"]["Limit"];
///   if (!limit_switch.can_cast<int>()) {
///     return false;
///   }
///   int limit = limit_switch.cast<int>();
/// \endcode
///
class Value {
public:
  Value();
  Value(const Switch * switch_);
  Value(int value);
  Value(bool value);
  Value(const StringType & value);
  Value(const CharType * value);
  
  enum {
    /// if the type is kTypeAuto then cast to any types are legal,
    /// assuming that operator>> can handle the conversion.
    kTypeAuto,  
    
    kTypeInt,
    kTypeBool,
    kTypeString
  };
  
  /// Returns the type held
  int type() const;

  /// Convert to an int.  Triggers a runtime assertion if the Value holds the
  /// wrong type.
  int AsInt() const;
  
  /// Convert to a bool.  Triggers a runtime assertion if the Value holds the
  /// wrong type.
  bool AsBool() const;
  
  /// Convert to a string.  Triggers a runtime assertion if the Value holds the
  /// wrong type.
  const StringType & AsString() const;
  
  /// Assign a value.  Note that assignment does invoke any validation
  /// associated with the Switch.
  void set(const Value & value);
  void set(int value);
  void set(bool value);
  void set(const StringType & value);
  void set(const CharType * value);
  
  /// Return the associated Switch or NULL.  The returned pointer is valid for
  /// the lifetime of the Value.
  const Switch * switch_() const;
  
  /// Implicit cast.  These casts may trigger assertions at runtime if the
  /// conversion cannot be completed.
  operator int() const;
  
  /// \copydoc Value::operator int()
  operator StringType() const;
  
  /// \copydoc Value::operator int()
  operator ConstCharArrayType() const;
  
  /// \copydoc Value::operator int()
  operator bool() const;
  
  Value & operator=(const Value & value);
  bool operator==(const Value & other) const;

private:
  int type_;
  union {
    int int_value_;
    bool bool_value_;
  };
  std::string string_value_;
  const Switch * switch__;
};

std::ostream& operator<< (std::ostream& out, const Value & value);

/// In some cases, switches may be grouped in collections with an arbitrary name,
/// for example, in the .INI format, you may have a something like this:
///
/// \code
///   someglobalswitch=true
///   
///   [alice@example.net]
///   name=Alice
///
///   [bob@example.com]
///   name=Bob
/// \endcode
///
/// In this case there are three switch groups: '', 'alice\@example.net' and
/// 'bob\@example.com'.  For platforms that support it, such as the Windows
/// registry and Apache-style, ValueGroup may themselves contain other
/// ValueGroups.
///
class ValueGroup {
 public:
  typedef std::vector<Value> ValueList;
  typedef std::map<StringType, ValueList> ValueMap;
  typedef std::map<StringType, ValueGroup> ValueGroupMap;

  explicit ValueGroup(const StringType & name = kEmptyString);

  /// Gets/Sets the name of this ValueGroup.  Relevant only if this group is
  /// contained by other ValueGroups.
  const StringType & name() const;
  ValueGroup & name(const StringType & name);

  /// Accessor for the full map of values in this group.
  const ValueMap & values() const;
  
  /// Accessor for a single named Value.  If the value occurs more than once,
  /// returns the first element.  DCHECKs if `name` is not a valid value.
  const Value & value(const StringType & name) const;

  /// Accessor for a named Value.  Returns a list of elements, even if the value
  /// occurs only once.  Returns an empty list if `name` is not a valid value.
  const ValueList & repeated_value(const StringType & name) const;

  /// Accessor for mapping of all subgroups
  const ValueGroupMap & groups() const;
  
  /// Accessor for a particular named subgroup
  const ValueGroup & group(const StringType & name) const;

  /// True if the value is present in the group
  bool has_value(const StringType & name) const;

  /// True if the group is present in the group
  bool has_group(const StringType & name) const;

  /// Set a single value.  Replaces any/all existing values in the group
  void SetValue(const StringType & name, const Value & value);

  /// Add an additional value.  Appends the value onto any existing values.
  void AddRepeatedValue(const StringType & name, const Value & value);

  /// Remove all instances of an existing value.
  void ClearValue(const StringType & name);

  /// Add a new group.  Nop if the group already exists.
  void AddGroup(const ValueGroup & group);
  
 private:
  StringType name_;
  ValueMap values_;
  ValueGroupMap groups_;
};

/// Defines a switch and constrains it's values.  It may specify the
/// type, names, how it is stored and other expectations.  You can attach a
/// SwitchValidator to define custom constraint behavior.
///
/// All setter functions return a self reference to allow accessor
/// chaining.  You can ignore the return value if you don't want to use this
/// syntax.  For example:
///
/// \code
///   parser.add_switch(Switch().name("verbose").short_flag('v').action("count")
///     .help("Produce verbose output, use more times for greater effect"));
/// \endcode
///
/// Also ok:
/// \code
///   Switch switch;
///   switch.name("verbose");
///   switch.short_flag('v');
///   switch.action("count");
///   parser.add_switch(switch);
/// \endcode
///
class Switch {
 public:
  enum {
    kActionStore,
    kActionStoreTrue,
    kActionStoreFalse,
    kActionStoreConstant,
    kActionAppend,
    kActionCount
  };
  
  Switch();
  Switch(const Switch & other);
  ~Switch();
  Switch& operator=(const Switch& b);
  
  /// List of all the possible long names for this switch
  const std::vector<StringType> & names() const;
    
  /// The primary name of the switch (the first name of the names() list)
  const StringType & name() const;
  
  /// Assign the name of the switch (or add an additional name)
  Switch & name(const StringType & name);

  CharType short_flag() const;
  Switch & short_flag(CharType short_flag);

  int action() const;
  Switch & action(int action);
  
  /// Specify the kActionStore action
  Switch & store() { return action(kActionStore); }
  
  /// Specify the kActionStoreTrue action
  Switch & store_true() { return action(kActionStoreTrue); }
  
  /// Specify the kActionStoreFalse action
  Switch & store_false() { return action(kActionStoreFalse); }
  
  /// Specify the kActionStoreConstant action
  Switch & store_constant() { return action(kActionStoreConstant); }
  
  /// Specify the kActionAppend action
  Switch & append() { return action(kActionAppend); }
  
  /// Specify the kActionCount action
  Switch & count() { return action(kActionCount); }

  /// The name of the Value for this switch.  By default this is the same as the
  /// value of name().
  const StringType & dest() const;
  Switch & dest(const StringType & dest);
  
  /// The value of the switch when kActionStoreConstant is specified
  const Value & constant() const;
  Switch & constant(const Value & constant);
  
  /// The value of the switch if nothing is specified
  const Value & default_() const;
  Switch & default_(const Value & default_);

  const std::vector<StringType> & choices() const;
  Switch & choice(const StringType & choice);
  
  /// The help text corresponding to this switch
  const StringType & help() const;
  Switch & help(const StringType & help);
  
  /// The name of the environment variable which can be used to specify this 
  /// switch.  By default, this is an uppercase version of the name, so if 
  /// the name were "foo-bar", then the command line argument is \c --foo-bar 
  /// and the environment variable is \c FOO_BAR
  const StringType & environment_variable() const;
  Switch & environment_variable(const StringType & environment_variable);
  
  /// A custom validator for the switch.
  SwitchValidator * validator() const;
  
  /// Assign a custom validator.  Ownership of the argument is transferred with
  /// the call which must be allocated with new.
  Switch & validator(SwitchValidator * validator);
  
private:
  std::vector<StringType> names_;
  CharType short_flag_;
  int action_;
  StringType dest_;
  Value constant_;
  Value default__;
  std::vector<StringType> choices_;
  StringType help_;
  StringType environment_variable_;
  SwitchValidator * validator_;
};

/// An abstract class which is the base for switch validators.  Assign
/// instances of this class with Switch::validator().  For examples of how to
/// implement a subclass, see InternetHostSwitchValidator, PortSwitchValidator.
/// Subclasses must implement Validate() in a meaningful way.
class SwitchValidator {
public:
  virtual ~SwitchValidator() {}
  
  /// Returns true if value is valid for the corresponding switch.
  virtual bool Validate(const Value & value) = 0;
};

/// This class constrains a set of switches to fall within the constraints
/// specified.  If a switch set is applied, then only switches explicitly
/// identified in the constraint set are accepted.  Use of a SwitchSet is
/// optional for both ConfigParser and ArgumentParser, but ArgumentParser cannot
/// cannonically determine the difference between boolean arguments and arguments
/// accepting a value.  E.g.:  --foo bar could be interpreted as a boolean flag
/// `foo` and a free argument `bar` or as a strings switch named `foo` whose
/// value is `bar`.
class SwitchSet {
public:
  typedef std::vector<Switch> List;
  typedef std::vector<std::pair<StringType, List> > GroupList;

  void insert(const Switch & switch_);
  void insert(const StringType & group, const Switch & switch_);
  
  const GroupList & switches() const;
  const List & switches(const StringType & group) const;
  const Switch & switch_(const StringType & group, const StringType & name);

  bool has_switch(const StringType & group, const StringType & name);
private:
  GroupList switches_;
};

/// This class implements the POSIX a standard argument parser with the GNU 
/// long options extension.
/// 
/// References
/// ----------
/// The GNU & POSIX argument standards are described in 
///   http://www.gnu.org/s/libc/manual/html_node/Argument-Syntax.html
///   http://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html
///  
/// For a list of helpful option names, see:
///   http://www.gnu.org/prep/standards/html_node/Option-Table.html

class ArgumentParser {
 public:
  ArgumentParser();
  
  const StringType & program() const;
  ArgumentParser & program(const StringType & program);

  const StringType & usage() const;
  ArgumentParser & usage(const StringType & usage);
  
  const StringType & version() const;
  ArgumentParser & version(const StringType & version);
  
  const SwitchSet & switch_set() const;
  ArgumentParser & switch_set(const SwitchSet & switch_set);
  
  /// If you choose, you can build swtiches one at a time by calling AddSwitch.
  /// Using this function is equivalent to building a SwitchSet and calling 
  /// switch_set().
  ArgumentParser & AddSwitch(const Switch & switch_);

  /// Flags that control the behavior of the Parse() function
  ArgumentParser & enable_parse_environment(bool enable_parse_environment);
  ArgumentParser & registry_prefix(const StringType & registry_prefix);
  // ... nop on platforms other than windos
  
  bool Parse(int argc, const CharType ** argv);
  bool Parse(const std::vector<StringType> & argv);

  /// A text description of the error if Parse() returns false
  const StringType & error() const;
  
  /// Returns the free arguments.  For example, if --verbose is a counter and the
  /// command line '--verbose foo --verbose' is specified, `foo` would be added
  /// to `arguments`
  const std::vector<StringType> & arguments() const;
  
  /// Returns the named switch value
  const Value & value(const std::string & name) const;
  const ValueGroup::ValueList & repeated_value(const std::string & name) const;
  
  /// Returns all the values
  const ValueGroup & values() const;

private:
  const Switch * GetSwitch(CharType ch) const;
  const Switch * GetSwitch(const StringType & name) const;
  bool SetValueWithArgument(const Switch & switch_, const StringType & value);
  bool SetValueWithoutArgument(const Switch & switch_);

  class Internal;

  StringType program_;
  StringType usage_;
  StringType version_;
  SwitchSet switch_set_;
  bool enable_parse_environment_;
  StringType registry_prefix_;
  std::vector<StringType> arguments_;
  ValueGroup values_;
  StringType error_;
};

/// This class encapsulates an error parsing a configuration file.  It 
class ConfigError {
  int line() const;
  int column() const;
  const StringType & message() const;
 private:
  ConfigError(int line, int column, const StringType & message);
  int line_;
  int column_;
  StringType message_;
  friend class ConfigParser;
};

/// This is a base class for the various configuration file formats that we
/// suppoort.  You should instantiate subclasses of this class such as
/// ApacheConfigParser, JsonConfigParser or IniConfigParser and use the interface
/// described here.
class ConfigParser {
 public:
  virtual ~ConfigParser();
  virtual bool Parse(const StringType & filename) = 0;
  
  const StringType & error() const;
  const ValueGroup & values() const;

  /// Sets the switch parser.  Global switches options map to an unnamed group
  /// in the SwitchSet.  Switches in groups which do not appear in the SwitchSet
  /// are mapped to the special group __fallback__.
  ConfigParser & switch_set(const SwitchSet & switch_set);
  const SwitchSet & switch_set() const;
  
  /// If true, then groups with no registered switch parser will be rejected.
  ConfigParser & reject_unknown_switches(bool reject_unknown_switches);
  bool reject_unknown_switches() const;
  
 protected:
  ConfigParser();

  StringType error_;
  ValueGroup values_;

  SwitchSet switch_set_;
  bool reject_unknown_switches_;
  
};

class ApacheConfigParser : public ConfigParser {
  virtual bool Parse(const StringType & filename);
};

class IniConfigParser : public ConfigParser {
public:
  IniConfigParser();
  virtual bool Parse(const StringType & filename);
  
private:
  bool Parse(FILE * fp);
  bool ParseLine(StringType & line, int line_number);
  bool AssignValue(const StringType & key, const StringType & value);
  StringType section_;
};

class JsonConfigParser : public ConfigParser {
  virtual bool Parse(const StringType & filename);
};

}  // namespace yact

#endif  // YACT_H_
